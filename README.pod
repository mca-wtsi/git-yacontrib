=head1 DESCRIPTION

These are small Git extension scripts I keep in C<~/bin/> and have on
my path.  Some could be in C<~/.gitconfig section [alias]>.

=head2 The short and obvious commands

=over 4

=item git br

C<git branch <args>>, or list branches

=item git ci

C<git commit <args>

=item git co

C<git checkout <args>>

=item git ff

C<git merge --ff-only <args>>

=item git g

C<git gui &>

=item git k

Basically C<gitk --all HEAD &>

=item git gk [ <workdir> ]

C<git g; git k>, optionally preceded by C<cd <workdir>>.  This is the
main tool I use when starting work in a project.

=item git iec

Create standard "initial empty commit".  This is the first thing I run
after C<git init foo; cd foo>.

=item git s

C<git status (...color...) --ignored --short --branch -u <args>>

=item git st

C<git status <args>>

=back

=head2 Longer or more complex commands

=over 4

=item git-P

C<git --no-pager <args>>

=item git commit-retro

Commit, making (Author, AuthorDate) from file stat.  Requires some
config to deal with other users.

=item git ireb

C<git rebase -i --autosquash> ...of whatever is not pushed

=item git log1

Details of last commit.

=item git logG

Textual graph of commits.

=item git rebase-topswap

Swap C<HEAD> and C<HEAD^> using C<git rebase -i>.

=item git rhH

=item git rhH ^

C<git reset --hard HEAD>,
C<git reset --hard HEAD^>

Scary command!  Only installs with C<./install.sh -yS ...>

=item git up

C<git pull --rebase <args>>

For those who use the linearised history, first-push-wins model.

=item git ll-cpanm, git ll-init

Install CPAN (Perl5) libraries, into a L<local::lib> directory under
Git control.

=back

=head2 Tools for scripts

=over 4

=item git compilation-annotate

 # "show me what's wrong with code written in the last 30 days"
 perlcritic --quiet --nocolour --verbose "%f:%l:%c:%m\t[%s] %p\n" \
    modules t/modules | git-compilation-annotate -n 30

=item git head

What's the current branch name, or HEAD commitid?

=item git qcommit

Commit noisily, or keep quiet if nothing to commit

=item git qpull

Pull noisily, or keep quiet if nothing is new

=back

=head2 Tools for hooks

=over 4

=item git rehash

For when SHA1 isn't strong enough.

=item git which-me

Which of my many email addresses am I using here?

=back

=head2 Incomplete or forgotten

Some tools looked like a good idea, or solved part of some transient
problem, or might be useful when completed.

 git-enumerate-commits
 git-enumerate-repos
 git-gc-du
 git-permsfix
 git-permsfix-shared-clone
 git-proxy-squid
 git-subtree-branch
 git-undzil
 mr-unconfigured-search


=head1 INSTALLATION

=head2 "Throw them in the ~/bin"

The current plan is to "install" them via symlinks,
  ln -snvf ../../../gitwk-github/scripts/bin/{git-rebase-topswap,pidfzap} ~/bin/

You must put that C<~/bin> on C<$PATH> yourself.

Running the supplied script with

 ./install -y ~/bin

will do this for you, in the way I currently prefer.

=head2 The scary scripts

Some scripts are too destructive to leave lying around on your PATH if
you don't know the name.  These may be installed, as a separate set,
with

 ./install -yS ~/bin

=head2 Details

For "installation" of multiple scripts from some source repositories,
I prefer to symlink a parent directory and then symlink various
scripts through that, so

 ,git-yacontrib -> $HOME/gitwk-ext/git-yacontrib/bin
 git-k -> ,git-yacontrib/git-k
 git-st -> ,git-yacontrib/git-st
  ...

so it's obvious which remaining files (presumably saved straight from
editor to ~/bin) ought to be put in version control.

The set of files installed is defined by F<install*.txt>.

=head1 MAINTENANCE

They are only maintained to the extent that I'm still using them.
You're welcome to fork on Github or by other means, and I would aim to
merge contributions as time allows.


=head1 PLANS & IDEAS

Vapourware.

=head2 git backup-stash

Something to generate a commit which could usefully be included in a
backup, to record more about the repo state, referencing some or all
of

=over 4

=item * all stashes in the reflog

Note that stashes recorded in the reflog
L<are not expired, since v1.5.6.6|https://github.com/git/git/commit/60bce2bb8b3cd5ca56f8156cbca16abee151d817>
but they aren't going to leave the local repository by an ordinary
push or fetch.

=item * other extant commitids from reflogs

This would allow recovery of not-yet-garbage-collected commits, from
commitid-based repository backups.  Possibly neat, but unlikely to be
useful?

=item * comment or extra file containing the reflog and head stash ref

=item * some of .git/config and related files?

=item * Untracked files.  Call it a tristash (staged, unstaged,
untracked)

Use another index?  Define size limits?

Ignored files?  What about files to exclude for security reasons?

=item * a tar of some .git/ internals

 logs/
 hooks/
 config
 info/exclude
 info/grafts
 COMMIT_EDITMSG
 GITGUI_BCK
 description
 objects/info/alternates

 git-svn state
 gitweb config

 hardlink counts & inode info for packfiles
    In combination with related matching backups could be used to
    reconstruct the hardlinked arrangement.  If you were desperate.

Many of these are things you wouldn't want to just restore.

=back

It will look like a huge merge (but isn't).

Related possibly useful things,

=over 4

=item * operations to reverse these back into reflog & stash, or
extract any one to become the current stash

=item * something that makes this tree clearly not part of the
project.

Empty, except for a shell script to help with the restoration?

=back

Naming

 git stashbranch
 git stash-branch
 git backup-stashes
 git _backup-stashes # we may assume it is called from cron, so avoid eating namespace?

=head2 git do-sync

(Have already implemented part of this as a tool inside my reminders
textfile repo.)

 commit (staged, changed, autosaved) files
 at both ends
 then (pull --rebase; push; remote ff) or similar

Configurable for rebase vs. merge, to allow for more than a pair of
repos.

=head2 git-wstash

"with a git stash, do"

 #! /bin/sh
 
 set -e
 set -x
 
 git stash save "with stash: $@"
 "$@"
 git stash pop
 
 # This would seem to need some extra safeguards,
 #
 #   if nothing to stash, just do command; else we pop an older stash!


=head1 SEE ALSO

=over 4

=item https://metacpan.org/module/App::IsGitSynced

=item https://github.com/aspiers/git-config

=item Github tools

L<https://github.com/github/hub>
L<App::GitHubPullRequest>

(via L<http://www.dagolden.com/index.php/2065/how-ive-started-managing-github-pulls/>)

=back


=head1 AUTHOR

I have written them in the course of my work for
http://www.sanger.ac.uk/ and for personal use.

The project "mcast/git-yacontrib" is released under GPLv2 or later,
per local policy.

(I realise this is far to vague to form a reliable declaration of
"release under GPLv2" except where explicit but marking for release
takes time, and it's probably better to make the thing visible and
wait for someone to ask for clarification.)

=cut
